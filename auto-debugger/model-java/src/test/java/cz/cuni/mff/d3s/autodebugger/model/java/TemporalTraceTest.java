package cz.cuni.mff.d3s.autodebugger.model.java;

import cz.cuni.mff.d3s.autodebugger.model.common.trace.TemporalTrace;
import cz.cuni.mff.d3s.autodebugger.model.java.identifiers.*;
import cz.cuni.mff.d3s.autodebugger.model.java.identifiers.JavaClassIdentifier;
import cz.cuni.mff.d3s.autodebugger.model.common.identifiers.ExportableValue;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;

import java.util.Map;
import java.util.Optional;
import java.util.SortedMap;

import static org.junit.jupiter.api.Assertions.*;

class TemporalTraceTest {
    
    private TemporalTrace trace;
    private ExportableValue argIdentifier;
    private ExportableValue fieldIdentifier;
    
    @BeforeEach
    void setUp() {
        trace = new TemporalTrace();
        
        // Create test identifiers
        argIdentifier = new JavaArgumentIdentifier(
            ArgumentIdentifierParameters.builder()
                .argumentSlot(0)
                .variableType("int")
                .build()
        );
        
        JavaClassIdentifier testClass = new JavaClassIdentifier(
            ClassIdentifierParameters.builder()
                .className("TestClass")
                .packageIdentifier(JavaPackageIdentifier.DEFAULT_PACKAGE)
                .build()
        );

        fieldIdentifier = new JavaFieldIdentifier(
            FieldIdentifierParameters.builder()
                .variableName("testField")
                .ownerClassIdentifier(testClass)
                .variableType("String")
                .build()
        );
    }
    
    @Test
    void givenExplicitEventIndex_whenAddingValue_thenStoresCorrectly() {
        trace.addValue(argIdentifier, 100, 42);
        trace.addValue(argIdentifier, 105, 84);
        
        SortedMap<Integer, Object> values = trace.getValues(argIdentifier);
        assertEquals(2, values.size());
        assertEquals(42, values.get(100));
        assertEquals(84, values.get(105));
    }
    
    @Test
    void givenAutoGeneratedEventIndex_whenAddingValue_thenGeneratesSequentialIndices() {
        int event1 = trace.addValue(argIdentifier, 10);
        int event2 = trace.addValue(argIdentifier, 20);
        
        assertEquals(0, event1);
        assertEquals(1, event2);
        
        SortedMap<Integer, Object> values = trace.getValues(argIdentifier);
        assertEquals(2, values.size());
        assertEquals(10, values.get(0));
        assertEquals(20, values.get(1));
    }
    
    @Test
    void givenMultipleValues_whenGettingLatestValueBefore_thenReturnsCorrectValue() {
        trace.addValue(argIdentifier, 100, "first");
        trace.addValue(argIdentifier, 200, "second");
        trace.addValue(argIdentifier, 300, "third");
        
        // Test exact match
        Optional<Object> value = trace.getLatestValueBefore(argIdentifier, 200);
        assertTrue(value.isPresent());
        assertEquals("second", value.get());
        
        // Test before first value
        value = trace.getLatestValueBefore(argIdentifier, 50);
        assertFalse(value.isPresent());
        
        // Test between values
        value = trace.getLatestValueBefore(argIdentifier, 250);
        assertTrue(value.isPresent());
        assertEquals("second", value.get());
        
        // Test after last value
        value = trace.getLatestValueBefore(argIdentifier, 400);
        assertTrue(value.isPresent());
        assertEquals("third", value.get());
    }
    
    @Test
    void givenNonExistentIdentifier_whenGettingLatestValueBefore_thenReturnsEmpty() {
        Optional<Object> value = trace.getLatestValueBefore(argIdentifier, 100);
        assertFalse(value.isPresent());
    }
    
    @Test
    void givenStoredValues_whenGettingValues_thenReturnsSortedMap() {
        trace.addValue(argIdentifier, 100, "value1");
        trace.addValue(argIdentifier, 200, "value2");
        
        SortedMap<Integer, Object> values = trace.getValues(argIdentifier);
        assertEquals(2, values.size());
        assertEquals("value1", values.get(100));
        assertEquals("value2", values.get(200));
        
        // Test that returned map is a copy
        values.put(300, "value3");
        assertEquals(2, trace.getValues(argIdentifier).size());
    }
    
    @Test
    void givenNonExistentIdentifier_whenGettingValues_thenReturnsEmptyMap() {
        SortedMap<Integer, Object> values = trace.getValues(argIdentifier);
        assertTrue(values.isEmpty());
    }
    
    @Test
    void givenMultipleIdentifiers_whenGettingStateSnapshot_thenReturnsCorrectState() {
        trace.addValue(argIdentifier, 100, 42);
        trace.addValue(fieldIdentifier, 150, "hello");
        trace.addValue(argIdentifier, 200, 84);
        
        // Snapshot at event 175 should include both variables
        Map<ExportableValue, Object> snapshot = trace.getStateSnapshotAt(175);
        assertEquals(2, snapshot.size());
        assertEquals(42, snapshot.get(argIdentifier));
        assertEquals("hello", snapshot.get(fieldIdentifier));
        
        // Snapshot at event 125 should only include argIdentifier
        snapshot = trace.getStateSnapshotAt(125);
        assertEquals(1, snapshot.size());
        assertEquals(42, snapshot.get(argIdentifier));
        assertFalse(snapshot.containsKey(fieldIdentifier));
        
        // Snapshot at event 250 should include updated argIdentifier
        snapshot = trace.getStateSnapshotAt(250);
        assertEquals(2, snapshot.size());
        assertEquals(84, snapshot.get(argIdentifier));
        assertEquals("hello", snapshot.get(fieldIdentifier));
    }
    
    @Test
    void givenTrackedIdentifiers_whenGettingTrackedIdentifiers_thenReturnsCorrectSet() {
        assertTrue(trace.getTrackedIdentifiers().isEmpty());
        
        trace.addValue(argIdentifier, 100, 42);
        assertEquals(1, trace.getTrackedIdentifiers().size());
        assertTrue(trace.getTrackedIdentifiers().contains(argIdentifier));
        
        trace.addValue(fieldIdentifier, 200, "test");
        assertEquals(2, trace.getTrackedIdentifiers().size());
        assertTrue(trace.getTrackedIdentifiers().contains(argIdentifier));
        assertTrue(trace.getTrackedIdentifiers().contains(fieldIdentifier));
    }
    
    @Test
    void givenEvents_whenGettingEventIndexRange_thenReturnsCorrectRange() {
        // Empty trace
        Optional<int[]> range = trace.getEventIndexRange();
        assertFalse(range.isPresent());
        
        // Single event
        trace.addValue(argIdentifier, 100, 42);
        range = trace.getEventIndexRange();
        assertTrue(range.isPresent());
        assertArrayEquals(new int[]{100, 100}, range.get());
        
        // Multiple events
        trace.addValue(fieldIdentifier, 50, "test");
        trace.addValue(argIdentifier, 200, 84);
        range = trace.getEventIndexRange();
        assertTrue(range.isPresent());
        assertArrayEquals(new int[]{50, 200}, range.get());
    }
    
    @Test
    void givenEvents_whenGettingTotalEventCount_thenReturnsCorrectCount() {
        assertEquals(0, trace.getTotalEventCount());
        
        trace.addValue(argIdentifier, 100, 42);
        assertEquals(1, trace.getTotalEventCount());
        
        trace.addValue(argIdentifier, 200, 84);
        assertEquals(2, trace.getTotalEventCount());
        
        trace.addValue(fieldIdentifier, 150, "test");
        assertEquals(3, trace.getTotalEventCount());
    }
    
    @Test
    void givenTrackedVariables_whenGettingTrackedVariableCount_thenReturnsCorrectCount() {
        assertEquals(0, trace.getTrackedVariableCount());
        
        trace.addValue(argIdentifier, 100, 42);
        assertEquals(1, trace.getTrackedVariableCount());
        
        trace.addValue(argIdentifier, 200, 84);
        assertEquals(1, trace.getTrackedVariableCount()); // Same variable
        
        trace.addValue(fieldIdentifier, 150, "test");
        assertEquals(2, trace.getTrackedVariableCount());
    }
    
    @Test
    void givenMetadata_whenSettingAndGetting_thenWorksCorrectly() {
        assertNull(trace.getMetadata("test_key"));
        
        trace.addMetadata("test_key", "test_value");
        assertEquals("test_value", trace.getMetadata("test_key"));
        
        trace.addMetadata("number_key", 42);
        assertEquals(42, trace.getMetadata("number_key"));
        
        Map<String, Object> allMetadata = trace.getAllMetadata();
        assertEquals(2, allMetadata.size());
        assertEquals("test_value", allMetadata.get("test_key"));
        assertEquals(42, allMetadata.get("number_key"));
    }
    
    @Test
    void givenPopulatedTrace_whenClearing_thenResetsToEmpty() {
        trace.addValue(argIdentifier, 100, 42);
        trace.addValue(fieldIdentifier, 200, "test");
        trace.addMetadata("key", "value");
        
        assertFalse(trace.getTrackedIdentifiers().isEmpty());
        assertTrue(trace.getTotalEventCount() > 0);
        assertNotNull(trace.getMetadata("key"));
        
        trace.clear();
        
        assertTrue(trace.getTrackedIdentifiers().isEmpty());
        assertEquals(0, trace.getTotalEventCount());
        assertNull(trace.getMetadata("key"));
    }
    
    @Test
    void givenPopulatedTrace_whenGettingSummary_thenReturnsCorrectSummary() {
        trace.addValue(argIdentifier, 100, 42);
        trace.addValue(fieldIdentifier, 200, "test");
        trace.addMetadata("test", "value");
        
        String summary = trace.getSummary();
        assertNotNull(summary);
        assertTrue(summary.contains("Tracked variables: 2"));
        assertTrue(summary.contains("Total events: 2"));
        assertTrue(summary.contains("Event range: [100, 200]"));
        assertTrue(summary.contains("Metadata entries: 1"));
    }
}
